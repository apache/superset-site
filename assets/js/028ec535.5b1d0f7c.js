"use strict";(self.webpackChunkdocs_v_2=self.webpackChunkdocs_v_2||[]).push([[3368],{47848:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>l,toc:()=>c});var i=t(74848),r=t(28453);const s={title:"SQL Templating",hide_title:!0,sidebar_position:5,version:1},a="SQL Templating",l={id:"configuration/sql-templating",title:"SQL Templating",description:"Jinja Templates",source:"@site/docs/configuration/sql-templating.mdx",sourceDirName:"configuration",slug:"/configuration/sql-templating",permalink:"/docs/configuration/sql-templating",draft:!1,unlisted:!1,editUrl:"https://github.com/apache/superset/edit/master/docs/docs/configuration/sql-templating.mdx",tags:[],version:"current",sidebarPosition:5,frontMatter:{title:"SQL Templating",hide_title:!0,sidebar_position:5,version:1},sidebar:"CustomSidebar",previous:{title:"Async Queries via Celery",permalink:"/docs/configuration/async-queries-celery"},next:{title:"Timezones",permalink:"/docs/configuration/timezones"}},o={},c=[{value:"Jinja Templates",id:"jinja-templates",level:2},{value:"Available Macros",id:"available-macros",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"sql-templating",children:"SQL Templating"})}),"\n",(0,i.jsx)(n.h2,{id:"jinja-templates",children:"Jinja Templates"}),"\n",(0,i.jsxs)(n.p,{children:["SQL Lab and Explore supports ",(0,i.jsx)(n.a,{href:"https://jinja.palletsprojects.com/en/2.11.x/",children:"Jinja templating"})," in queries.\nTo enable templating, the ",(0,i.jsx)(n.code,{children:"ENABLE_TEMPLATE_PROCESSING"})," ",(0,i.jsx)(n.a,{href:"/docs/configuration/configuring-superset#feature-flags",children:"feature flag"})," needs to be enabled in\n",(0,i.jsx)(n.code,{children:"superset_config.py"}),". When templating is enabled, python code can be embedded in virtual datasets and\nin Custom SQL in the filter and metric controls in Explore. By default, the following variables are\nmade available in the Jinja context:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"columns"}),": columns which to group by in the query"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"filter"}),": filters applied in the query"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"from_dttm"}),": start ",(0,i.jsx)(n.code,{children:"datetime"})," value from the selected time range (",(0,i.jsx)(n.code,{children:"None"})," if undefined) (deprecated beginning in version 5.0, use ",(0,i.jsx)(n.code,{children:"get_time_filter"})," instead)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"to_dttm"}),": end ",(0,i.jsx)(n.code,{children:"datetime"})," value from the selected time range (",(0,i.jsx)(n.code,{children:"None"})," if undefined). (deprecated beginning in version 5.0, use ",(0,i.jsx)(n.code,{children:"get_time_filter"})," instead)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"groupby"}),": columns which to group by in the query (deprecated)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"metrics"}),": aggregate expressions in the query"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"row_limit"}),": row limit of the query"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"row_offset"}),": row offset of the query"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"table_columns"}),": columns available in the dataset"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"time_column"}),": temporal column of the query (",(0,i.jsx)(n.code,{children:"None"})," if undefined)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"time_grain"}),": selected time grain (",(0,i.jsx)(n.code,{children:"None"})," if undefined)"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"For example, to add a time range to a virtual dataset, you can write the following:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"SELECT *\nFROM tbl\nWHERE dttm_col > '{{ from_dttm }}' and dttm_col < '{{ to_dttm }}'\n"})}),"\n",(0,i.jsxs)(n.p,{children:["You can also use ",(0,i.jsx)(n.a,{href:"https://jinja.palletsprojects.com/en/2.11.x/templates/#tests",children:"Jinja's logic"}),"\nto make your query robust to clearing the timerange filter:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"SELECT *\nFROM tbl\nWHERE (\n    {% if from_dttm is not none %}\n        dttm_col > '{{ from_dttm }}' AND\n    {% endif %}\n    {% if to_dttm is not none %}\n        dttm_col < '{{ to_dttm }}' AND\n    {% endif %}\n    true\n)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Note how the Jinja parameters are called within double brackets in the query, and without in the\nlogic blocks."}),"\n",(0,i.jsxs)(n.p,{children:["To add custom functionality to the Jinja context, you need to overload the default Jinja\ncontext in your environment by defining the ",(0,i.jsx)(n.code,{children:"JINJA_CONTEXT_ADDONS"})," in your superset configuration\n(",(0,i.jsx)(n.code,{children:"superset_config.py"}),"). Objects referenced in this dictionary are made available for users to use\nwhere the Jinja context is made available."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"JINJA_CONTEXT_ADDONS = {\n    'my_crazy_macro': lambda x: x*2,\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Default values for jinja templates can be specified via ",(0,i.jsx)(n.code,{children:"Parameters"})," menu in the SQL Lab user interface.\nIn the UI you can assign a set of parameters as JSON"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n  "my_table": "foo"\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["The parameters become available in your SQL (example: ",(0,i.jsx)(n.code,{children:"SELECT * FROM {{ my_table }}"})," ) by using Jinja templating syntax.\nSQL Lab template parameters are stored with the dataset as ",(0,i.jsx)(n.code,{children:"TEMPLATE PARAMETERS"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["There is a special ",(0,i.jsx)(n.code,{children:"_filters"})," parameter which can be used to test filters used in the jinja template."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n  "_filters": [\n    {\n      "col": "action_type",\n      "op": "IN",\n      "val": ["sell", "buy"]\n    }\n  ]\n}\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"SELECT action, count(*) as times\nFROM logs\nWHERE action in {{ filter_values('action_type')|where_in }}\nGROUP BY action\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Note ",(0,i.jsx)(n.code,{children:"_filters"})," is not stored with the dataset. It's only used within the SQL Lab UI."]}),"\n",(0,i.jsxs)(n.p,{children:["Besides default Jinja templating, SQL lab also supports self-defined template processor by setting\nthe ",(0,i.jsx)(n.code,{children:"CUSTOM_TEMPLATE_PROCESSORS"})," in your superset configuration. The values in this dictionary\noverwrite the default Jinja template processors of the specified database engine. The example below\nconfigures a custom presto template processor which implements its own logic of processing macro\ntemplate with regex parsing. It uses the ",(0,i.jsx)(n.code,{children:"$"})," style macro instead of ",(0,i.jsx)(n.code,{children:"{{ }}"})," style in Jinja\ntemplating."]}),"\n",(0,i.jsxs)(n.p,{children:["By configuring it with ",(0,i.jsx)(n.code,{children:"CUSTOM_TEMPLATE_PROCESSORS"}),", a SQL template on a presto database is\nprocessed by the custom one rather than the default one."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'def DATE(\n    ts: datetime, day_offset: SupportsInt = 0, hour_offset: SupportsInt = 0\n) -> str:\n    """Current day as a string."""\n    day_offset, hour_offset = int(day_offset), int(hour_offset)\n    offset_day = (ts + timedelta(days=day_offset, hours=hour_offset)).date()\n    return str(offset_day)\n\nclass CustomPrestoTemplateProcessor(PrestoTemplateProcessor):\n    """A custom presto template processor."""\n\n    engine = "presto"\n\n    def process_template(self, sql: str, **kwargs) -> str:\n        """Processes a sql template with $ style macro using regex."""\n        # Add custom macros functions.\n        macros = {\n            "DATE": partial(DATE, datetime.utcnow())\n        }  # type: Dict[str, Any]\n        # Update with macros defined in context and kwargs.\n        macros.update(self.context)\n        macros.update(kwargs)\n\n        def replacer(match):\n            """Expand $ style macros with corresponding function calls."""\n            macro_name, args_str = match.groups()\n            args = [a.strip() for a in args_str.split(",")]\n            if args == [""]:\n                args = []\n            f = macros[macro_name[1:]]\n            return f(*args)\n\n        macro_names = ["$" + name for name in macros.keys()]\n        pattern = r"(%s)\\s*\\(([^()]*)\\)" % "|".join(map(re.escape, macro_names))\n        return re.sub(pattern, replacer, sql)\n\nCUSTOM_TEMPLATE_PROCESSORS = {\n    CustomPrestoTemplateProcessor.engine: CustomPrestoTemplateProcessor\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"SQL Lab also includes a live query validation feature with pluggable backends. You can configure\nwhich validation implementation is used with which database engine by adding a block like the\nfollowing to your configuration file:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"FEATURE_FLAGS = {\n    'SQL_VALIDATORS_BY_ENGINE': {\n        'presto': 'PrestoDBSQLValidator',\n    }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The available validators and names can be found in\n",(0,i.jsx)(n.a,{href:"https://github.com/apache/superset/tree/master/superset/sql_validators",children:"sql_validators"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"available-macros",children:"Available Macros"}),"\n",(0,i.jsx)(n.p,{children:"In this section, we'll walkthrough the pre-defined Jinja macros in Superset."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Current Username"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"{{ current_username() }}"})," macro returns the ",(0,i.jsx)(n.code,{children:"username"})," of the currently logged in user."]}),"\n",(0,i.jsxs)(n.p,{children:["If you have caching enabled in your Superset configuration, then by default the ",(0,i.jsx)(n.code,{children:"username"})," value will be used\nby Superset when calculating the cache key. A cache key is a unique identifier that determines if there's a\ncache hit in the future and Superset can retrieve cached data."]}),"\n",(0,i.jsxs)(n.p,{children:["You can disable the inclusion of the ",(0,i.jsx)(n.code,{children:"username"})," value in the calculation of the\ncache key by adding the following parameter to your Jinja code:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"{{ current_username(add_to_cache_keys=False) }}\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Current User ID"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"{{ current_user_id() }}"})," macro returns the account ID of the currently logged in user."]}),"\n",(0,i.jsxs)(n.p,{children:["If you have caching enabled in your Superset configuration, then by default the account ",(0,i.jsx)(n.code,{children:"id"})," value will be used\nby Superset when calculating the cache key. A cache key is a unique identifier that determines if there's a\ncache hit in the future and Superset can retrieve cached data."]}),"\n",(0,i.jsxs)(n.p,{children:["You can disable the inclusion of the account ",(0,i.jsx)(n.code,{children:"id"})," value in the calculation of the\ncache key by adding the following parameter to your Jinja code:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"{{ current_user_id(add_to_cache_keys=False) }}\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Current User Email"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"{{ current_user_email() }}"})," macro returns the email address of the currently logged in user."]}),"\n",(0,i.jsx)(n.p,{children:"If you have caching enabled in your Superset configuration, then by default the email address value will be used\nby Superset when calculating the cache key. A cache key is a unique identifier that determines if there's a\ncache hit in the future and Superset can retrieve cached data."}),"\n",(0,i.jsx)(n.p,{children:"You can disable the inclusion of the email value in the calculation of the\ncache key by adding the following parameter to your Jinja code:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"{{ current_user_email(add_to_cache_keys=False) }}\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Custom URL Parameters"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"{{ url_param('custom_variable') }}"})," macro lets you define arbitrary URL\nparameters and reference them in your SQL code."]}),"\n",(0,i.jsx)(n.p,{children:"Here's a concrete example:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"You write the following query in SQL Lab:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"SELECT count(*)\nFROM ORDERS\nWHERE country_code = '{{ url_param('countrycode') }}'\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["You're hosting Superset at the domain ",(0,i.jsx)(n.a,{href:"http://www.example.com",children:"www.example.com"})," and you send your\ncoworker in Spain the following SQL Lab URL ",(0,i.jsx)(n.code,{children:"www.example.com/superset/sqllab?countrycode=ES"}),"\nand your coworker in the USA the following SQL Lab URL ",(0,i.jsx)(n.code,{children:"www.example.com/superset/sqllab?countrycode=US"})]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"For your coworker in Spain, the SQL Lab query will be rendered as:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"SELECT count(*)\nFROM ORDERS\nWHERE country_code = 'ES'\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"For your coworker in the USA, the SQL Lab query will be rendered as:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"SELECT count(*)\nFROM ORDERS\nWHERE country_code = 'US'\n"})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Explicitly Including Values in Cache Key"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"{{ cache_key_wrapper() }}"})," function explicitly instructs Superset to add a value to the\naccumulated list of values used in the calculation of the cache key."]}),"\n",(0,i.jsxs)(n.p,{children:["This function is only needed when you want to wrap your own custom function return values\nin the cache key. You can gain more context\n",(0,i.jsx)(n.a,{href:"https://github.com/apache/superset/blob/efd70077014cbed62e493372d33a2af5237eaadf/superset/jinja_context.py#L133-L148",children:"here"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Note that this function powers the caching of the ",(0,i.jsx)(n.code,{children:"user_id"})," and ",(0,i.jsx)(n.code,{children:"username"})," values\nin the ",(0,i.jsx)(n.code,{children:"current_user_id()"})," and ",(0,i.jsx)(n.code,{children:"current_username()"})," function calls (if you have caching enabled)."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Filter Values"})}),"\n",(0,i.jsxs)(n.p,{children:["You can retrieve the value for a specific filter as a list using ",(0,i.jsx)(n.code,{children:"{{ filter_values() }}"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"This is useful if:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"You want to use a filter component to filter a query where the name of filter component column doesn't match the one in the select statement"}),"\n",(0,i.jsx)(n.li,{children:"You want to have the ability for filter inside the main query for performance purposes"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Here's a concrete example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"SELECT action, count(*) as times\nFROM logs\nWHERE\n    action in {{ filter_values('action_type')|where_in }}\nGROUP BY action\n"})}),"\n",(0,i.jsxs)(n.p,{children:["There ",(0,i.jsx)(n.code,{children:"where_in"})," filter converts the list of values from ",(0,i.jsx)(n.code,{children:"filter_values('action_type')"})," into a string suitable for an ",(0,i.jsx)(n.code,{children:"IN"})," expression."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Filters for a Specific Column"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"{{ get_filters() }}"})," macro returns the filters applied to a given column. In addition to\nreturning the values (similar to how ",(0,i.jsx)(n.code,{children:"filter_values()"})," does), the ",(0,i.jsx)(n.code,{children:"get_filters()"})," macro\nreturns the operator specified in the Explore UI."]}),"\n",(0,i.jsx)(n.p,{children:"This is useful if:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"You want to handle more than the IN operator in your SQL clause"}),"\n",(0,i.jsx)(n.li,{children:"You want to handle generating custom SQL conditions for a filter"}),"\n",(0,i.jsx)(n.li,{children:"You want to have the ability to filter inside the main query for speed purposes"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Here's a concrete example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:" WITH RECURSIVE\n    superiors(employee_id, manager_id, full_name, level, lineage) AS (\n    SELECT\n        employee_id,\n        manager_id,\n        full_name,\n    1 as level,\n    employee_id as lineage\n    FROM\n        employees\n    WHERE\n    1=1\n\n    {# Render a blank line #}\n    {%- for filter in get_filters('full_name', remove_filter=True) -%}\n\n    {%- if filter.get('op') == 'IN' -%}\n        AND\n        full_name IN {{ filter.get('val')|where_in }}\n    {%- endif -%}\n\n    {%- if filter.get('op') == 'LIKE' -%}\n        AND\n        full_name LIKE {{ \"'\" + filter.get('val') + \"'\" }}\n    {%- endif -%}\n\n    {%- endfor -%}\n    UNION ALL\n        SELECT\n            e.employee_id,\n            e.manager_id,\n            e.full_name,\n    s.level + 1 as level,\n    s.lineage\n        FROM\n            employees e,\n        superiors s\n        WHERE s.manager_id = e.employee_id\n    )\n\n    SELECT\n    employee_id, manager_id, full_name, level, lineage\n    FROM\n    superiors\n    order by lineage, level\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Time Filter"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"{{ get_time_filter() }}"})," macro returns the time filter applied to a specific column. This is useful if you want\nto handle time filters inside the virtual dataset, as by default the time filter is placed on the outer query. This can\nconsiderably improve performance, as many databases and query engines are able to optimize the query better\nif the temporal filter is placed on the inner query, as opposed to the outer query."]}),"\n",(0,i.jsx)(n.p,{children:"The macro takes the following parameters:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"column"}),": Name of the temporal column. Leave undefined to reference the time range from a Dashboard Native Time Range\nfilter (when present)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"default"}),": The default value to fall back to if the time filter is not present, or has the value ",(0,i.jsx)(n.code,{children:"No filter"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"target_type"}),": The target temporal type as recognized by the target  database (e.g. ",(0,i.jsx)(n.code,{children:"TIMESTAMP"}),", ",(0,i.jsx)(n.code,{children:"DATE"})," or\n",(0,i.jsx)(n.code,{children:"DATETIME"}),"). If ",(0,i.jsx)(n.code,{children:"column"})," is defined, the format will default to the type of the column. This is used to produce\nthe format of the ",(0,i.jsx)(n.code,{children:"from_expr"})," and ",(0,i.jsx)(n.code,{children:"to_expr"})," properties of the returned ",(0,i.jsx)(n.code,{children:"TimeFilter"})," object."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"strftime"}),": format using the ",(0,i.jsx)(n.code,{children:"strftime"})," method of ",(0,i.jsx)(n.code,{children:"datetime"})," for custom time formatting.\n(",(0,i.jsx)(n.a,{href:"https://docs.python.org/3/library/datetime.html#strftime-and-strptime-format-codes",children:"see docs for valid format codes"}),").\nWhen defined ",(0,i.jsx)(n.code,{children:"target_type"})," will be ignored."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"remove_filter"}),": When set to true, mark the filter as processed, removing it from the outer query. Useful when a\nfilter should only apply to the inner query."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"The return type has the following properties:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"from_expr"}),": the start of the time filter (if any)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"to_expr"}),": the end of the time filter (if any)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"time_range"}),": The applied time range"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Here's a concrete example using the ",(0,i.jsx)(n.code,{children:"logs"})," table from the Superset metastore:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"{% set time_filter = get_time_filter(\"dttm\", remove_filter=True) %}\n{% set from_expr = time_filter.from_expr %}\n{% set to_expr = time_filter.to_expr %}\n{% set time_range = time_filter.time_range %}\nSELECT\n  *,\n  '{{ time_range }}' as time_range\nFROM logs\n{% if from_expr or to_expr %}WHERE 1 = 1\n{% if from_expr %}AND dttm >= {{ from_expr }}{% endif %}\n{% if to_expr %}AND dttm < {{ to_expr }}{% endif %}\n{% endif %}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Assuming we are creating a table chart with a simple ",(0,i.jsx)(n.code,{children:"COUNT(*)"})," as the metric with a time filter ",(0,i.jsx)(n.code,{children:"Last week"})," on the\n",(0,i.jsx)(n.code,{children:"dttm"})," column, this would render the following query on Postgres (note the formatting of the temporal filters, and\nthe absence of time filters on the outer query):"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"SELECT COUNT(*) AS count\nFROM\n  (SELECT *,\n          'Last week' AS time_range\n   FROM public.logs\n   WHERE 1 = 1\n     AND dttm >= TO_TIMESTAMP('2024-08-27 00:00:00.000000', 'YYYY-MM-DD HH24:MI:SS.US')\n     AND dttm < TO_TIMESTAMP('2024-09-03 00:00:00.000000', 'YYYY-MM-DD HH24:MI:SS.US')) AS virtual_table\nORDER BY count DESC\nLIMIT 1000;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["When using the ",(0,i.jsx)(n.code,{children:"default"})," parameter, the templated query can be simplified, as the endpoints will always be defined\n(to use a fixed time range, you can also use something like ",(0,i.jsx)(n.code,{children:'default="2024-08-27 : 2024-09-03"'}),")"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'{% set time_filter = get_time_filter("dttm", default="Last week", remove_filter=True) %}\nSELECT\n  *,\n  \'{{ time_filter.time_range }}\' as time_range\nFROM logs\nWHERE\n  dttm >= {{ time_filter.from_expr }}\n  AND dttm < {{ time_filter.to_expr }}\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Datasets"})}),"\n",(0,i.jsxs)(n.p,{children:["It's possible to query physical and virtual datasets using the ",(0,i.jsx)(n.code,{children:"dataset"})," macro. This is useful if you've defined computed columns and metrics on your datasets, and want to reuse the definition in adhoc SQL Lab queries."]}),"\n",(0,i.jsxs)(n.p,{children:["To use the macro, first you need to find the ID of the dataset. This can be done by going to the view showing all the datasets, hovering over the dataset you're interested in, and looking at its URL. For example, if the URL for a dataset is ",(0,i.jsx)(n.a,{href:"https://superset.example.org/explore/?dataset_type=table&dataset_id=42",children:"https://superset.example.org/explore/?dataset_type=table&dataset_id=42"})," its ID is 42."]}),"\n",(0,i.jsx)(n.p,{children:"Once you have the ID you can query it as if it were a table:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"SELECT * FROM {{ dataset(42) }} LIMIT 10\n"})}),"\n",(0,i.jsx)(n.p,{children:"If you want to select the metric definitions as well, in addition to the columns, you need to pass an additional keyword argument:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"SELECT * FROM {{ dataset(42, include_metrics=True) }} LIMIT 10\n"})}),"\n",(0,i.jsx)(n.p,{children:"Since metrics are aggregations, the resulting SQL expression will be grouped by all non-metric columns. You can specify a subset of columns to group by instead:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'SELECT * FROM {{ dataset(42, include_metrics=True, columns=["ds", "category"]) }} LIMIT 10\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Metrics"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"{{ metric('metric_key', dataset_id) }}"})," macro can be used to retrieve the metric SQL syntax from a dataset. This can be useful for different purposes:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Override the metric label in the chart level"}),"\n",(0,i.jsx)(n.li,{children:"Combine multiple metrics in a calculation"}),"\n",(0,i.jsx)(n.li,{children:"Retrieve a metric syntax in SQL lab"}),"\n",(0,i.jsx)(n.li,{children:"Re-use metrics across datasets"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"This macro avoids copy/paste, allowing users to centralize the metric definition in the dataset layer."}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"dataset_id"})," parameter is optional, and if not provided Superset will use the current dataset from context (for example, when using this macro in the Chart Builder, by default the ",(0,i.jsx)(n.code,{children:"macro_key"})," will be searched in the dataset powering the chart).\nThe parameter can be used in SQL Lab, or when fetching a metric from another dataset."]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>l});var i=t(96540);const r={},s=i.createContext(r);function a(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);